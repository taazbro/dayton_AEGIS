"""
Advanced AI Malware Detector â€” Detect "Just-in-Time" AI Malware
Based on Google GTIG Report (November 2025)

REAL-WORLD THREATS DETECTED:
1. PROMPTFLUX - Self-modifying malware using Gemini API (Russia)
2. PROMPTSTEAL - APT28 malware querying LLMs for commands (Russia â†’ Ukraine)
3. PROMPTLOCK - Ransomware generating Lua scripts via LLM (Experimental)
4. QUIETVAULT - Credential stealer using AI CLI tools (In the wild)
5. FRUITSHELL - Reverse shell with LLM evasion prompts (In the wild)

This represents the first documented "just-in-time" AI malware that dynamically
generates malicious code during execution.

AEGIS DEFENSE:
Detects all 5 malware families based on their unique AI signatures
"""

from typing import Dict, Any, List
import re
from collections import defaultdict


class AdvancedAIMalwareDetector:
    """
    Detect advanced AI-powered malware families documented by Google GTIG.

    THREAT INTELLIGENCE:
    - Source: Google Threat Intelligence Group (GTIG)
    - Date: November 2025
    - Report: "AI Threat Tracker: Advances in Threat Actor Usage of AI Tools"

    MALWARE FAMILIES:
    - PROMPTFLUX: Self-modifying dropper (Gemini API)
    - PROMPTSTEAL: APT28 data miner (Hugging Face API)
    - PROMPTLOCK: Cross-platform ransomware (LLM-generated Lua)
    - QUIETVAULT: Credential stealer (AI CLI tools)
    - FRUITSHELL: Reverse shell (LLM evasion)
    """

    def __init__(self):
        self.detection_signatures = {
            "promptflux": [],
            "promptsteal": [],
            "promptlock": [],
            "quietvault": [],
            "fruitshell": [],
            "generic_ai_malware": []
        }

    def detect_ai_malware_family(self, events: List[Dict[str, Any]], network_data: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Detect specific AI malware families based on GTIG intelligence.

        Args:
            events: Security events
            network_data: Network traffic data (optional)

        Returns:
            Detection results with identified malware family
        """
        detections = {
            "promptflux": self._detect_promptflux(events, network_data),
            "promptsteal": self._detect_promptsteal(events, network_data),
            "promptlock": self._detect_promptlock(events),
            "quietvault": self._detect_quietvault(events),
            "fruitshell": self._detect_fruitshell(events)
        }

        # Determine primary threat
        detected_families = [family for family, result in detections.items() if result["detected"]]

        if not detected_families:
            return {
                "ai_malware_detected": False,
                "family": None,
                "confidence": 0.0
            }

        # Get highest confidence detection
        primary_detection = max(
            [(family, detections[family]) for family in detected_families],
            key=lambda x: x[1]["confidence"]
        )

        family_name, family_data = primary_detection

        return {
            "ai_malware_detected": True,
            "family": family_name.upper(),
            "confidence": family_data["confidence"],
            "characteristics": family_data["characteristics"],
            "threat_actor": family_data.get("threat_actor"),
            "reference": "Google GTIG November 2025",
            "all_detections": detected_families,
            "mitigation": self._get_family_mitigation(family_name)
        }

    def _detect_promptflux(self, events: List[Dict[str, Any]], network_data: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Detect PROMPTFLUX - Self-modifying dropper using Gemini API.

        SIGNATURES:
        - Queries Gemini API (generativelanguage.googleapis.com)
        - Uses "gemini-1.5-flash-latest" model
        - "Thinking Robot" module pattern
        - VBScript obfuscation requests
        - Logs to %TEMP%\thinking_robot_log.txt
        - Hourly self-regeneration
        """
        confidence = 0.0
        characteristics = []

        # Check for Gemini API calls
        gemini_api_calls = 0
        thinking_robot_pattern = False
        vbscript_obfuscation = False

        for event in events:
            event_str = str(event).lower()

            # Signature 1: Gemini API interaction
            if "generativelanguage.googleapis.com" in event_str or "gemini" in event_str:
                gemini_api_calls += 1
                characteristics.append("Gemini API calls detected")

            # Signature 2: "Thinking Robot" module
            if "thinking" in event_str and "robot" in event_str:
                thinking_robot_pattern = True
                characteristics.append("'Thinking Robot' pattern detected")
                confidence += 0.3

            # Signature 3: VBScript obfuscation requests
            if "vbscript" in event_str and "obfuscat" in event_str:
                vbscript_obfuscation = True
                characteristics.append("VBScript obfuscation requests")
                confidence += 0.2

            # Signature 4: Self-modification patterns
            if "rewrite" in event_str and "source" in event_str:
                characteristics.append("Self-modification detected")
                confidence += 0.2

        # Check network data for API patterns
        if network_data:
            if "generativelanguage.googleapis.com" in str(network_data):
                gemini_api_calls += 1

        if gemini_api_calls > 0:
            confidence += min(0.3, gemini_api_calls * 0.1)

        return {
            "detected": confidence > 0.5,
            "confidence": min(confidence, 1.0),
            "characteristics": characteristics,
            "threat_actor": "Unknown (Russian-speaking indicators)",
            "status": "Experimental"
        }

    def _detect_promptsteal(self, events: List[Dict[str, Any]], network_data: Dict[str, Any] = None) -> Dict[str, Any]:
        r"""
        Detect PROMPTSTEAL - APT28 data miner using Hugging Face API.

        SIGNATURES:
        - Queries Hugging Face API (api-inference.huggingface.co)
        - Uses Qwen2.5-Coder-32B-Instruct model
        - Generates Windows commands via LLM
        - Targets C:\Programdata\info folder
        - Collects system info, hardware, AD domain
        - Copies office/PDF documents
        - Masquerades as image generation program
        """
        confidence = 0.0
        characteristics = []

        huggingface_api = False
        system_info_collection = False
        document_collection = False
        programdata_folder = False

        for event in events:
            event_str = str(event).lower()

            # Signature 1: Hugging Face API
            if "huggingface" in event_str or "api-inference.huggingface.co" in event_str:
                huggingface_api = True
                characteristics.append("Hugging Face API detected")
                confidence += 0.3

            # Signature 2: Qwen model usage
            if "qwen" in event_str:
                characteristics.append("Qwen model usage")
                confidence += 0.2

            # Signature 3: System info collection pattern
            if any(keyword in event_str for keyword in ["computer information", "hardware information", "ad domain"]):
                system_info_collection = True
                characteristics.append("System enumeration")
                confidence += 0.2

            # Signature 4: C:\Programdata\info folder
            if "programdata" in event_str and "info" in event_str:
                programdata_folder = True
                characteristics.append("Programdata\\info folder usage")
                confidence += 0.2

            # Signature 5: Document collection
            if any(keyword in event_str for keyword in ["documents", "downloads", "desktop", "office", "pdf"]):
                document_collection = True
                characteristics.append("Document harvesting")
                confidence += 0.1

        return {
            "detected": confidence > 0.5,
            "confidence": min(confidence, 1.0),
            "characteristics": characteristics,
            "threat_actor": "APT28 (FROZENLAKE) - Russian GRU",
            "target": "Ukraine",
            "status": "Active in operations"
        }

    def _detect_promptlock(self, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Detect PROMPTLOCK - Cross-platform ransomware using LLM-generated Lua.

        SIGNATURES:
        - Written in Go (cross-platform)
        - Generates Lua scripts via LLM at runtime
        - Filesystem reconnaissance
        - Data exfiltration
        - File encryption (Windows + Linux)
        """
        confidence = 0.0
        characteristics = []

        for event in events:
            event_str = str(event).lower()

            # Signature 1: Lua script generation
            if "lua" in event_str and ("generate" in event_str or "script" in event_str):
                characteristics.append("Lua script generation")
                confidence += 0.3

            # Signature 2: Filesystem reconnaissance
            if "filesystem" in event_str or "file scan" in event_str:
                characteristics.append("Filesystem reconnaissance")
                confidence += 0.2

            # Signature 3: Encryption activities
            if "encrypt" in event_str or "ransom" in event_str:
                characteristics.append("Encryption detected")
                confidence += 0.3

            # Signature 4: Cross-platform indicators
            if ("windows" in event_str and "linux" in event_str) or "cross-platform" in event_str:
                characteristics.append("Cross-platform capabilities")
                confidence += 0.2

        return {
            "detected": confidence > 0.5,
            "confidence": min(confidence, 1.0),
            "characteristics": characteristics,
            "status": "Proof of concept"
        }

    def _detect_quietvault(self, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Detect QUIETVAULT - Credential stealer using AI CLI tools.

        SIGNATURES:
        - Written in JavaScript
        - Targets GitHub and NPM tokens
        - Uses on-host AI CLI tools
        - Creates public GitHub repo for exfiltration
        - AI prompts to find secrets
        """
        confidence = 0.0
        characteristics = []

        for event in events:
            event_str = str(event).lower()

            # Signature 1: GitHub token targeting
            if any(keyword in event_str for keyword in ["github", "npm", "token"]):
                characteristics.append("GitHub/NPM token targeting")
                confidence += 0.2

            # Signature 2: Public repo exfiltration
            if "github" in event_str and "repository" in event_str:
                characteristics.append("GitHub repo exfiltration")
                confidence += 0.3

            # Signature 3: AI CLI usage
            if "ai" in event_str and "cli" in event_str:
                characteristics.append("AI CLI tools detected")
                confidence += 0.3

            # Signature 4: Secret searching
            if "secret" in event_str or "credential" in event_str:
                characteristics.append("Secret enumeration")
                confidence += 0.2

        return {
            "detected": confidence > 0.5,
            "confidence": min(confidence, 1.0),
            "characteristics": characteristics,
            "status": "Active in operations"
        }

    def _detect_fruitshell(self, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Detect FRUITSHELL - Reverse shell with LLM evasion.

        SIGNATURES:
        - PowerShell reverse shell
        - Hard-coded prompts for LLM-powered security bypass
        - C2 connection
        - Arbitrary command execution
        """
        confidence = 0.0
        characteristics = []

        for event in events:
            event_str = str(event).lower()

            # Signature 1: PowerShell usage
            if "powershell" in event_str:
                characteristics.append("PowerShell detected")
                confidence += 0.2

            # Signature 2: Reverse shell indicators
            if "reverse" in event_str and "shell" in event_str:
                characteristics.append("Reverse shell pattern")
                confidence += 0.3

            # Signature 3: LLM evasion prompts
            if "llm" in event_str or ("prompt" in event_str and "bypass" in event_str):
                characteristics.append("LLM evasion prompts")
                confidence += 0.3

            # Signature 4: C2 communication
            if "c2" in event_str or "command and control" in event_str:
                characteristics.append("C2 communication")
                confidence += 0.2

        return {
            "detected": confidence > 0.5,
            "confidence": min(confidence, 1.0),
            "characteristics": characteristics,
            "status": "Active in operations"
        }

    def _get_family_mitigation(self, family: str) -> List[str]:
        """Get mitigation strategies for specific malware family"""

        mitigations = {
            "promptflux": [
                "IMMEDIATE: Block access to generativelanguage.googleapis.com at firewall",
                "IMMEDIATE: Monitor for VBScript execution",
                "IMMEDIATE: Check %TEMP% for thinking_robot_log.txt",
                "SHORT-TERM: Implement API key rotation policies",
                "LONG-TERM: Deploy behavioral analysis for self-modifying code"
            ],
            "promptsteal": [
                "IMMEDIATE: Block Hugging Face API (api-inference.huggingface.co)",
                "IMMEDIATE: Monitor C:\\Programdata\\info folder creation",
                "IMMEDIATE: Alert on document mass-copy operations",
                "SHORT-TERM: Deploy APT28 IOCs across network",
                "LONG-TERM: Implement DLP for document exfiltration"
            ],
            "promptlock": [
                "IMMEDIATE: Block Lua script generation at runtime",
                "IMMEDIATE: Enable endpoint encryption protection",
                "IMMEDIATE: Backup critical files (ransomware defense)",
                "SHORT-TERM: Monitor for filesystem reconnaissance",
                "LONG-TERM: Implement behavioral ransomware detection"
            ],
            "quietvault": [
                "IMMEDIATE: Rotate all GitHub and NPM tokens",
                "IMMEDIATE: Monitor for public repo creation",
                "IMMEDIATE: Scan for AI CLI tool installations",
                "SHORT-TERM: Implement secrets detection scanning",
                "LONG-TERM: Zero-trust secret management"
            ],
            "fruitshell": [
                "IMMEDIATE: Block unauthorized PowerShell execution",
                "IMMEDIATE: Monitor for reverse shell connections",
                "IMMEDIATE: Inspect prompts sent to LLM security tools",
                "SHORT-TERM: Network segmentation to limit C2",
                "LONG-TERM: Application whitelisting enforcement"
            ]
        }

        return mitigations.get(family, [
            "Monitor for AI API usage in malware",
            "Block unauthorized LLM API access",
            "Deploy behavioral analysis",
            "Implement zero-trust architecture"
        ])

    def generate_detection_report(self, detection: Dict[str, Any]) -> str:
        """Generate detailed report for AI malware detection"""

        if not detection.get("ai_malware_detected"):
            return "No advanced AI malware detected"

        family = detection["family"]
        confidence = detection["confidence"]

        report = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸš¨ ADVANCED AI MALWARE DETECTED: {family.upper():20s}           â•‘
â•‘  Google GTIG Intelligence (November 2025)                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸  MALWARE FAMILY: {family.upper()}
ðŸ“Š CONFIDENCE: {confidence:.1%}
ðŸ”— INTELLIGENCE SOURCE: {detection['reference']}
"""

        if detection.get("threat_actor"):
            report += f"ðŸŽ¯ THREAT ACTOR: {detection['threat_actor']}\n"

        report += f"\nðŸ” DETECTED CHARACTERISTICS:\n"
        for char in detection.get("characteristics", []):
            report += f"   â€¢ {char}\n"

        report += f"\nðŸ›¡ï¸ RECOMMENDED MITIGATION:\n"
        for i, action in enumerate(detection.get("mitigation", []), 1):
            report += f"   {i}. {action}\n"

        if len(detection.get("all_detections", [])) > 1:
            report += f"\nâš¡ MULTIPLE AI MALWARE FAMILIES DETECTED:\n"
            for detected_family in detection["all_detections"]:
                report += f"   â€¢ {detected_family.upper()}\n"

        # Add family-specific information
        family_info = {
            "PROMPTFLUX": "Self-modifying dropper using Gemini API for dynamic obfuscation",
            "PROMPTSTEAL": "APT28 (Russian GRU) malware - Active against Ukraine",
            "PROMPTLOCK": "Cross-platform ransomware with LLM-generated Lua scripts",
            "QUIETVAULT": "GitHub/NPM credential stealer with AI-powered secret finding",
            "FRUITSHELL": "PowerShell reverse shell with LLM security bypass"
        }

        if family in family_info:
            report += f"\nðŸ“– THREAT DESCRIPTION:\n   {family_info[family]}\n"

        report += f"""
âš¡ SEVERITY: CRITICAL - "Just-in-Time" AI Malware
ðŸŽ¯ ATTACK TYPE: AI-powered autonomous malware
ðŸ“š FIRST OBSERVED: 2025 (GTIG Report)

ðŸ’¡ AEGIS is one of the first defense systems capable of detecting
   these advanced AI-powered malware families in real-time.
"""

        return report


# Global instance
_advanced_ai_malware_detector = None


def get_advanced_ai_malware_detector() -> AdvancedAIMalwareDetector:
    """Get singleton advanced AI malware detector"""
    global _advanced_ai_malware_detector
    if _advanced_ai_malware_detector is None:
        _advanced_ai_malware_detector = AdvancedAIMalwareDetector()
    return _advanced_ai_malware_detector
